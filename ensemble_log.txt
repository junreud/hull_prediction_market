2025-11-13 15:29:05,314 - prediction_market - INFO - Starting: Data loading
2025-11-13 15:29:05,322 - prediction_market - INFO - Starting: Loading data
2025-11-13 15:29:05,322 - prediction_market - INFO - Loading train data from data/raw/train.csv
2025-11-13 15:29:05,390 - prediction_market - INFO - Loading test data from data/raw/test.csv
2025-11-13 15:29:05,393 - prediction_market - INFO - Feature groups identified:
2025-11-13 15:29:05,393 - prediction_market - INFO -   M: 18 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   E: 20 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   I: 9 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   P: 13 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   V: 13 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   S: 12 features
2025-11-13 15:29:05,393 - prediction_market - INFO -   D: 9 features
2025-11-13 15:29:05,395 - prediction_market - INFO - Data loaded and sorted by date_id
2025-11-13 15:29:05,395 - prediction_market - INFO - Completed: Loading data - Time: 0.07s
2025-11-13 15:29:05,395 - prediction_market - INFO - Completed: Data loading - Time: 0.08s
2025-11-13 15:29:05,395 - prediction_market - INFO - Starting: Feature engineering
2025-11-13 15:29:05,402 - prediction_market - INFO - Feature Engineering initialized
2025-11-13 15:29:05,402 - prediction_market - INFO - Rolling windows: [5, 10, 20, 40, 60]
2025-11-13 15:29:05,402 - prediction_market - INFO - Lag periods: [1, 2, 3, 5, 10]
2025-11-13 15:29:05,402 - prediction_market - INFO - Scaler type: robust
2025-11-13 15:29:05,402 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:05,402 - prediction_market - INFO - Starting Feature Engineering Pipeline
2025-11-13 15:29:05,402 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:05,404 - prediction_market - INFO - Starting: Feature Engineering
2025-11-13 15:29:05,404 - prediction_market - INFO - 
Original features by group:
2025-11-13 15:29:05,404 - prediction_market - INFO -   M (Market): 18 features
2025-11-13 15:29:05,404 - prediction_market - INFO -   E (Economic): 20 features
2025-11-13 15:29:05,404 - prediction_market - INFO -   P (Price): 13 features
2025-11-13 15:29:05,404 - prediction_market - INFO -   V (Volatility): 13 features
2025-11-13 15:29:05,404 - prediction_market - INFO -   S (Sentiment): 12 features
2025-11-13 15:29:05,404 - prediction_market - INFO - 
1. Creating rolling features...
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:141: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_mean_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:146: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_std_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:151: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_min_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:155: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_roll_max_{window}'] = df[col].rolling(
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:160: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_dev_{window}'] = (
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:166: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_zscore_{window}'] = np.where(
2025-11-13 15:29:05,642 - prediction_market - INFO - Created rolling features for 31 columns
2025-11-13 15:29:05,642 - prediction_market - INFO - 
2. Creating lag features...
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:209: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_lag_{lag}'] = df[col].shift(lag)
2025-11-13 15:29:05,721 - prediction_market - INFO - Created lag features for 51 columns
2025-11-13 15:29:05,722 - prediction_market - INFO - 
3. Creating difference features...
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:256: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_accel'] = df_new[f'{col}_diff_1'].diff(1)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:249: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_diff_{period}'] = df[col].diff(period)
/Users/gimjunseog/projects/kaggle/Prediction_Market/src/features.py:252: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df_new[f'{col}_pct_{period}'] = df[col].pct_change(period)
2025-11-13 15:29:05,806 - prediction_market - INFO - Created difference features for 31 columns
2025-11-13 15:29:05,806 - prediction_market - INFO - 
4. Creating interaction features...
2025-11-13 15:29:05,876 - prediction_market - INFO - Created interaction features for 3 group pairs
2025-11-13 15:29:05,877 - prediction_market - INFO - 
5. Creating technical features...
2025-11-13 15:29:06,016 - prediction_market - INFO - Created technical features for 5 columns
2025-11-13 15:29:06,016 - prediction_market - INFO - 
6. Creating regime features...
2025-11-13 15:29:06,829 - prediction_market - INFO - Created regime features for 3 columns
2025-11-13 15:29:06,830 - prediction_market - INFO - Completed: Feature Engineering - Time: 1.43s
2025-11-13 15:29:06,831 - prediction_market - INFO - 
 Feature engineering complete!
2025-11-13 15:29:06,831 - prediction_market - INFO -   Original features: 96
2025-11-13 15:29:06,831 - prediction_market - INFO -   Engineered features: 1497
2025-11-13 15:29:06,831 - prediction_market - INFO -   Total features: 1593
2025-11-13 15:29:06,831 - prediction_market - INFO - Completed: Feature engineering - Time: 1.44s
2025-11-13 15:29:06,831 - prediction_market - INFO - Starting: Feature selection
2025-11-13 15:29:07,005 - prediction_market - INFO - Completed: Feature selection - Time: 0.17s
2025-11-13 15:29:07,005 - prediction_market - INFO - Starting: Model 1 training
2025-11-13 15:29:07,020 - prediction_market - INFO - CV Strategy initialized
2025-11-13 15:29:07,020 - prediction_market - INFO - Configuration: {'n_splits': 5, 'embargo': 5, 'purge': True, 'purge_period': 15, 'train_ratio': 0.8}
2025-11-13 15:29:07,020 - prediction_market - INFO - ReturnPredictor initialized with lightgbm
2025-11-13 15:29:07,020 - prediction_market - INFO - Model params: {'boosting_type': 'gbdt', 'objective': 'regression', 'metric': 'rmse', 'num_leaves': 31, 'learning_rate': 0.05, 'feature_fraction': 0.8, 'bagging_fraction': 0.8, 'bagging_freq': 5, 'max_depth': -1, 'min_child_samples': 20, 'n_estimators': 1000, 'random_state': 42, 'verbosity': -1, 'early_stopping_rounds': 50}
2025-11-13 15:29:07,021 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:07,021 - prediction_market - INFO - Starting Cross-Validation Training
2025-11-13 15:29:07,021 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:07,033 - prediction_market - INFO - 
Features: 1591
2025-11-13 15:29:07,033 - prediction_market - INFO - Samples: 9021
2025-11-13 15:29:07,033 - prediction_market - INFO - Date range: 0 to 9020
2025-11-13 15:29:07,034 - prediction_market - INFO - Starting Purged Walk-Forward CV with 5 splits
2025-11-13 15:29:07,034 - prediction_market - INFO - Total dates: 9021, Fold size: 1804
2025-11-13 15:29:07,034 - prediction_market - INFO - Embargo: 5, Purge: True, Purge period: 15, Train ratio: 0.8
2025-11-13 15:29:07,034 - prediction_market - INFO - Fold 1/5: Train dates: 1789 (0 to 1788), Val dates: 1804 (1804 to 3607), Train samples: 1789, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:07,034 - prediction_market - INFO - Fold 2/5: Train dates: 3593 (0 to 3592), Val dates: 1804 (3608 to 5411), Train samples: 3593, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:07,035 - prediction_market - INFO - Fold 3/5: Train dates: 5397 (0 to 5396), Val dates: 1804 (5412 to 7215), Train samples: 5397, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:07,035 - prediction_market - INFO - Fold 4/5: Train dates: 7201 (0 to 7200), Val dates: 1804 (7216 to 9019), Train samples: 7201, Val samples: 1804, Purged: 15 dates from train end, Embargo: 1 dates
2025-11-13 15:29:07,045 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:07,045 - prediction_market - INFO - Fold 1
2025-11-13 15:29:07,045 - prediction_market - INFO - ============================================================
2025-11-13 15:29:07,045 - prediction_market - INFO - Train samples: 1789
2025-11-13 15:29:07,045 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:07,046 - prediction_market - INFO - Starting: Training LGBM Fold 1
2025-11-13 15:29:07,595 - prediction_market - INFO - Completed: Training LGBM Fold 1 - Time: 0.55s
2025-11-13 15:29:07,603 - prediction_market - INFO - Fold 1 validation score: 0.012812
2025-11-13 15:29:07,613 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:07,613 - prediction_market - INFO - Fold 2
2025-11-13 15:29:07,613 - prediction_market - INFO - ============================================================
2025-11-13 15:29:07,613 - prediction_market - INFO - Train samples: 3593
2025-11-13 15:29:07,613 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:07,613 - prediction_market - INFO - Starting: Training LGBM Fold 2
2025-11-13 15:29:08,301 - prediction_market - INFO - Completed: Training LGBM Fold 2 - Time: 0.69s
2025-11-13 15:29:08,318 - prediction_market - INFO - Fold 2 validation score: 0.011594
2025-11-13 15:29:08,332 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:08,332 - prediction_market - INFO - Fold 3
2025-11-13 15:29:08,332 - prediction_market - INFO - ============================================================
2025-11-13 15:29:08,332 - prediction_market - INFO - Train samples: 5397
2025-11-13 15:29:08,332 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:08,332 - prediction_market - INFO - Starting: Training LGBM Fold 3
2025-11-13 15:29:09,141 - prediction_market - INFO - Completed: Training LGBM Fold 3 - Time: 0.81s
2025-11-13 15:29:09,149 - prediction_market - INFO - Fold 3 validation score: 0.008833
2025-11-13 15:29:09,169 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:09,169 - prediction_market - INFO - Fold 4
2025-11-13 15:29:09,169 - prediction_market - INFO - ============================================================
2025-11-13 15:29:09,169 - prediction_market - INFO - Train samples: 7201
2025-11-13 15:29:09,169 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:09,169 - prediction_market - INFO - Starting: Training LGBM Fold 4
2025-11-13 15:29:10,369 - prediction_market - INFO - Completed: Training LGBM Fold 4 - Time: 1.20s
2025-11-13 15:29:10,377 - prediction_market - INFO - Fold 4 validation score: 0.011100
2025-11-13 15:29:10,378 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:10,378 - prediction_market - INFO - Cross-Validation Results
2025-11-13 15:29:10,378 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:10,378 - prediction_market - INFO - 
Fold Scores (RMSE):
2025-11-13 15:29:10,378 - prediction_market - INFO -   Fold 1: 0.012812
2025-11-13 15:29:10,378 - prediction_market - INFO -   Fold 2: 0.011594
2025-11-13 15:29:10,378 - prediction_market - INFO -   Fold 3: 0.008833
2025-11-13 15:29:10,378 - prediction_market - INFO -   Fold 4: 0.011100
2025-11-13 15:29:10,378 - prediction_market - INFO - 
Mean CV Score: 0.011085 (+/- 0.001442)
2025-11-13 15:29:10,378 - prediction_market - INFO - OOF Score: 0.011178
2025-11-13 15:29:10,379 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:10,379 - prediction_market - INFO - Feature Importance (Top 20)
2025-11-13 15:29:10,379 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:10,379 - prediction_market - INFO -   M4_dev_40: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   V13: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   P11_diff_5: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   V9_roll_std_60: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   V7: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   I2_div_P10: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   M4_diff_10: 0.00
2025-11-13 15:29:10,379 - prediction_market - INFO -   P6_pct_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   P11_lag_2: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   P3: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M4_roll_mean_40: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M10_zscore_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M8_roll_mean_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M9_dev_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   P11_lag_5: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   E19_lag_5: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M18_dev_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M17_lag_2: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M17_lag_1: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO -   M16_lag_10: 0.00
2025-11-13 15:29:10,380 - prediction_market - INFO - Completed: Model 1 training - Time: 3.38s
2025-11-13 15:29:10,380 - prediction_market - INFO - Starting: Model 2 training
2025-11-13 15:29:10,395 - prediction_market - INFO - CV Strategy initialized
2025-11-13 15:29:10,395 - prediction_market - INFO - Configuration: {'n_splits': 5, 'embargo': 5, 'purge': True, 'purge_period': 15, 'train_ratio': 0.8}
2025-11-13 15:29:10,395 - prediction_market - INFO - ReturnPredictor initialized with lightgbm
2025-11-13 15:29:10,395 - prediction_market - INFO - Model params: {'boosting_type': 'gbdt', 'objective': 'regression', 'metric': 'rmse', 'num_leaves': 31, 'learning_rate': 0.05, 'feature_fraction': 0.8, 'bagging_fraction': 0.8, 'bagging_freq': 5, 'max_depth': -1, 'min_child_samples': 20, 'n_estimators': 1000, 'random_state': 42, 'verbosity': -1, 'early_stopping_rounds': 50}
2025-11-13 15:29:10,395 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:10,395 - prediction_market - INFO - Starting Cross-Validation Training
2025-11-13 15:29:10,395 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:10,430 - prediction_market - INFO - 
Features: 1591
2025-11-13 15:29:10,430 - prediction_market - INFO - Samples: 9021
2025-11-13 15:29:10,430 - prediction_market - INFO - Date range: 0 to 9020
2025-11-13 15:29:10,431 - prediction_market - INFO - Starting Purged Walk-Forward CV with 5 splits
2025-11-13 15:29:10,431 - prediction_market - INFO - Total dates: 9021, Fold size: 1804
2025-11-13 15:29:10,431 - prediction_market - INFO - Embargo: 5, Purge: True, Purge period: 15, Train ratio: 0.8
2025-11-13 15:29:10,431 - prediction_market - INFO - Fold 1/5: Train dates: 1789 (0 to 1788), Val dates: 1804 (1804 to 3607), Train samples: 1789, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:10,431 - prediction_market - INFO - Fold 2/5: Train dates: 3593 (0 to 3592), Val dates: 1804 (3608 to 5411), Train samples: 3593, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:10,431 - prediction_market - INFO - Fold 3/5: Train dates: 5397 (0 to 5396), Val dates: 1804 (5412 to 7215), Train samples: 5397, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:10,432 - prediction_market - INFO - Fold 4/5: Train dates: 7201 (0 to 7200), Val dates: 1804 (7216 to 9019), Train samples: 7201, Val samples: 1804, Purged: 15 dates from train end, Embargo: 1 dates
2025-11-13 15:29:10,439 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:10,439 - prediction_market - INFO - Fold 1
2025-11-13 15:29:10,439 - prediction_market - INFO - ============================================================
2025-11-13 15:29:10,439 - prediction_market - INFO - Train samples: 1789
2025-11-13 15:29:10,439 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:10,439 - prediction_market - INFO - Starting: Training LGBM Fold 1
2025-11-13 15:29:11,102 - prediction_market - INFO - Completed: Training LGBM Fold 1 - Time: 0.66s
2025-11-13 15:29:11,109 - prediction_market - INFO - Fold 1 validation score: 0.012822
2025-11-13 15:29:11,125 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:11,125 - prediction_market - INFO - Fold 2
2025-11-13 15:29:11,125 - prediction_market - INFO - ============================================================
2025-11-13 15:29:11,125 - prediction_market - INFO - Train samples: 3593
2025-11-13 15:29:11,125 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:11,125 - prediction_market - INFO - Starting: Training LGBM Fold 2
2025-11-13 15:29:12,436 - prediction_market - INFO - Completed: Training LGBM Fold 2 - Time: 1.31s
2025-11-13 15:29:12,444 - prediction_market - INFO - Fold 2 validation score: 0.011578
2025-11-13 15:29:12,460 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:12,460 - prediction_market - INFO - Fold 3
2025-11-13 15:29:12,460 - prediction_market - INFO - ============================================================
2025-11-13 15:29:12,460 - prediction_market - INFO - Train samples: 5397
2025-11-13 15:29:12,460 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:12,460 - prediction_market - INFO - Starting: Training LGBM Fold 3
2025-11-13 15:29:13,820 - prediction_market - INFO - Completed: Training LGBM Fold 3 - Time: 1.36s
2025-11-13 15:29:13,828 - prediction_market - INFO - Fold 3 validation score: 0.008811
2025-11-13 15:29:13,891 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:13,891 - prediction_market - INFO - Fold 4
2025-11-13 15:29:13,891 - prediction_market - INFO - ============================================================
2025-11-13 15:29:13,891 - prediction_market - INFO - Train samples: 7201
2025-11-13 15:29:13,891 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:13,891 - prediction_market - INFO - Starting: Training LGBM Fold 4
2025-11-13 15:29:15,972 - prediction_market - INFO - Completed: Training LGBM Fold 4 - Time: 2.08s
2025-11-13 15:29:15,985 - prediction_market - INFO - Fold 4 validation score: 0.011081
2025-11-13 15:29:15,986 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:15,986 - prediction_market - INFO - Cross-Validation Results
2025-11-13 15:29:15,986 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:15,986 - prediction_market - INFO - 
Fold Scores (RMSE):
2025-11-13 15:29:15,986 - prediction_market - INFO -   Fold 1: 0.012822
2025-11-13 15:29:15,986 - prediction_market - INFO -   Fold 2: 0.011578
2025-11-13 15:29:15,986 - prediction_market - INFO -   Fold 3: 0.008811
2025-11-13 15:29:15,986 - prediction_market - INFO -   Fold 4: 0.011081
2025-11-13 15:29:15,986 - prediction_market - INFO - 
Mean CV Score: 0.011073 (+/- 0.001452)
2025-11-13 15:29:15,986 - prediction_market - INFO - OOF Score: 0.011168
2025-11-13 15:29:15,989 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:15,989 - prediction_market - INFO - Feature Importance (Top 20)
2025-11-13 15:29:15,989 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:15,991 - prediction_market - INFO -   M4_dev_60: 0.01
2025-11-13 15:29:15,991 - prediction_market - INFO -   P3_lag_2: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M11_diff_1: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V13_dev_5: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M4_dev_40: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   S8: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M17_diff_1: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V7_roll_mean_20: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M18_accel: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   P11_diff_10: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M5_lag_5: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M9_diff_5: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V7_roll_std_40: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   P9_pct_5: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M8_roll_std_20: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   M4_diff_10: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V7_roll_min_10: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V5_dev_20: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   P7_diff_10: 0.00
2025-11-13 15:29:15,991 - prediction_market - INFO -   V3_roll_std_60: 0.00
2025-11-13 15:29:15,992 - prediction_market - INFO - Completed: Model 2 training - Time: 5.61s
2025-11-13 15:29:15,992 - prediction_market - INFO - Starting: Model 3 training
2025-11-13 15:29:16,007 - prediction_market - INFO - CV Strategy initialized
2025-11-13 15:29:16,007 - prediction_market - INFO - Configuration: {'n_splits': 5, 'embargo': 5, 'purge': True, 'purge_period': 15, 'train_ratio': 0.8}
2025-11-13 15:29:16,007 - prediction_market - INFO - ReturnPredictor initialized with lightgbm
2025-11-13 15:29:16,007 - prediction_market - INFO - Model params: {'boosting_type': 'gbdt', 'objective': 'regression', 'metric': 'rmse', 'num_leaves': 31, 'learning_rate': 0.05, 'feature_fraction': 0.8, 'bagging_fraction': 0.8, 'bagging_freq': 5, 'max_depth': -1, 'min_child_samples': 20, 'n_estimators': 1000, 'random_state': 42, 'verbosity': -1, 'early_stopping_rounds': 50}
2025-11-13 15:29:16,007 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:16,008 - prediction_market - INFO - Starting Cross-Validation Training
2025-11-13 15:29:16,008 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:16,083 - prediction_market - INFO - 
Features: 1591
2025-11-13 15:29:16,083 - prediction_market - INFO - Samples: 9021
2025-11-13 15:29:16,084 - prediction_market - INFO - Date range: 0 to 9020
2025-11-13 15:29:16,087 - prediction_market - INFO - Starting Purged Walk-Forward CV with 5 splits
2025-11-13 15:29:16,087 - prediction_market - INFO - Total dates: 9021, Fold size: 1804
2025-11-13 15:29:16,087 - prediction_market - INFO - Embargo: 5, Purge: True, Purge period: 15, Train ratio: 0.8
2025-11-13 15:29:16,088 - prediction_market - INFO - Fold 1/5: Train dates: 1789 (0 to 1788), Val dates: 1804 (1804 to 3607), Train samples: 1789, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:16,089 - prediction_market - INFO - Fold 2/5: Train dates: 3593 (0 to 3592), Val dates: 1804 (3608 to 5411), Train samples: 3593, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:16,090 - prediction_market - INFO - Fold 3/5: Train dates: 5397 (0 to 5396), Val dates: 1804 (5412 to 7215), Train samples: 5397, Val samples: 1804, Purged: 15 dates from train end, Embargo: 5 dates
2025-11-13 15:29:16,090 - prediction_market - INFO - Fold 4/5: Train dates: 7201 (0 to 7200), Val dates: 1804 (7216 to 9019), Train samples: 7201, Val samples: 1804, Purged: 15 dates from train end, Embargo: 1 dates
2025-11-13 15:29:16,103 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:16,103 - prediction_market - INFO - Fold 1
2025-11-13 15:29:16,103 - prediction_market - INFO - ============================================================
2025-11-13 15:29:16,103 - prediction_market - INFO - Train samples: 1789
2025-11-13 15:29:16,103 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:16,103 - prediction_market - INFO - Starting: Training LGBM Fold 1
2025-11-13 15:29:16,354 - prediction_market - INFO - Completed: Training LGBM Fold 1 - Time: 0.25s
2025-11-13 15:29:16,360 - prediction_market - INFO - Fold 1 validation score: 0.012819
2025-11-13 15:29:16,375 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:16,375 - prediction_market - INFO - Fold 2
2025-11-13 15:29:16,375 - prediction_market - INFO - ============================================================
2025-11-13 15:29:16,375 - prediction_market - INFO - Train samples: 3593
2025-11-13 15:29:16,375 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:16,375 - prediction_market - INFO - Starting: Training LGBM Fold 2
2025-11-13 15:29:16,726 - prediction_market - INFO - Completed: Training LGBM Fold 2 - Time: 0.35s
2025-11-13 15:29:16,732 - prediction_market - INFO - Fold 2 validation score: 0.011590
2025-11-13 15:29:16,751 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:16,751 - prediction_market - INFO - Fold 3
2025-11-13 15:29:16,751 - prediction_market - INFO - ============================================================
2025-11-13 15:29:16,751 - prediction_market - INFO - Train samples: 5397
2025-11-13 15:29:16,751 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:16,751 - prediction_market - INFO - Starting: Training LGBM Fold 3
2025-11-13 15:29:17,295 - prediction_market - INFO - Completed: Training LGBM Fold 3 - Time: 0.54s
2025-11-13 15:29:17,302 - prediction_market - INFO - Fold 3 validation score: 0.008813
2025-11-13 15:29:17,314 - prediction_market - INFO - 
============================================================
2025-11-13 15:29:17,314 - prediction_market - INFO - Fold 4
2025-11-13 15:29:17,314 - prediction_market - INFO - ============================================================
2025-11-13 15:29:17,314 - prediction_market - INFO - Train samples: 7201
2025-11-13 15:29:17,314 - prediction_market - INFO - Val samples: 1804
2025-11-13 15:29:17,314 - prediction_market - INFO - Starting: Training LGBM Fold 4
2025-11-13 15:29:18,025 - prediction_market - INFO - Completed: Training LGBM Fold 4 - Time: 0.71s
2025-11-13 15:29:18,032 - prediction_market - INFO - Fold 4 validation score: 0.011098
2025-11-13 15:29:18,032 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:18,032 - prediction_market - INFO - Cross-Validation Results
2025-11-13 15:29:18,032 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:18,032 - prediction_market - INFO - 
Fold Scores (RMSE):
2025-11-13 15:29:18,032 - prediction_market - INFO -   Fold 1: 0.012819
2025-11-13 15:29:18,032 - prediction_market - INFO -   Fold 2: 0.011590
2025-11-13 15:29:18,032 - prediction_market - INFO -   Fold 3: 0.008813
2025-11-13 15:29:18,032 - prediction_market - INFO -   Fold 4: 0.011098
2025-11-13 15:29:18,032 - prediction_market - INFO - 
Mean CV Score: 0.011080 (+/- 0.001451)
2025-11-13 15:29:18,032 - prediction_market - INFO - OOF Score: 0.011174
2025-11-13 15:29:18,033 - prediction_market - INFO - 
================================================================================
2025-11-13 15:29:18,033 - prediction_market - INFO - Feature Importance (Top 20)
2025-11-13 15:29:18,033 - prediction_market - INFO - ================================================================================
2025-11-13 15:29:18,033 - prediction_market - INFO -   D1: 0.00
2025-11-13 15:29:18,033 - prediction_market - INFO -   M18_lag_1: 0.00
2025-11-13 15:29:18,033 - prediction_market - INFO -   M17_lag_5: 0.00
2025-11-13 15:29:18,033 - prediction_market - INFO -   M17_lag_3: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M17_lag_2: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M17_lag_1: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M16_lag_10: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M16_lag_5: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M16_lag_3: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M16_lag_2: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M16_lag_1: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M15_lag_10: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M15_lag_5: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M15_lag_3: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M15_lag_2: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M15_lag_1: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M14_lag_10: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M14_lag_5: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M14_lag_3: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO -   M14_lag_2: 0.00
2025-11-13 15:29:18,034 - prediction_market - INFO - Completed: Model 3 training - Time: 2.04s
2025-11-13 15:29:18,122 - prediction_market - INFO - QuantileBinningMapper initialized
2025-11-13 15:29:18,122 - prediction_market - INFO - Allocation range: [0.0, 2.0]
2025-11-13 15:29:18,122 - prediction_market - INFO - Max vol ratio: 1.2
2025-11-13 15:29:18,122 - prediction_market - INFO - Max leverage pct: 0.1
2025-11-13 15:29:18,122 - prediction_market - INFO - Quantile Binning: 7 bins
2025-11-13 15:29:18,122 - prediction_market - INFO - Allocations: [0.  0.3 0.6 1.  1.4 1.7 2. ]
[I 2025-11-13 15:29:18,123] A new study created in memory with name: no-name-d4403a66-7d57-48e6-83bf-2b60aaf06f2f
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[1]	train's rmse: 0.0108177	valid's rmse: 0.00883299
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[1]	train's rmse: 0.00744354	valid's rmse: 0.012822
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[4]	train's rmse: 0.0102968	valid's rmse: 0.0115778
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[1]	train's rmse: 0.0108239	valid's rmse: 0.00881127
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[1]	train's rmse: 0.00746468	valid's rmse: 0.0128187
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
Training until validation scores don't improve for 50 rounds
  0%|          | 0/100 [00:00<?, ?it/s]                                         0%|          | 0/100 [00:00<?, ?it/s]Best trial: 0. Best value: 0.0278402:   0%|          | 0/100 [00:00<?, ?it/s]                                                                             Best trial: 0. Best value: 0.0278402:   1%|          | 1/100 [00:00<00:00, 316.65it/s]Best trial: 1. Best value: 0.0297138:   1%|          | 1/100 [00:00<00:00, 306.62it/s]                                                                                      Best trial: 1. Best value: 0.0297138:   2%|         | 2/100 [00:00<00:00, 504.76it/s]Best trial: 1. Best value: 0.0297138:   2%|         | 2/100 [00:00<00:00, 490.79it/s]                                                                                      Best trial: 1. Best value: 0.0297138:   3%|         | 3/100 [00:00<00:00, 631.96it/s]Best trial: 1. Best value: 0.0297138:   3%|         | 3/100 [00:00<00:00, 620.06it/s]                                                                                      Best trial: 1. Best value: 0.0297138:   4%|         | 4/100 [00:00<00:00, 723.97it/s]Best trial: 4. Best value: 0.0297594:   4%|         | 4/100 [00:00<00:00, 711.59it/s]                                                                                      Best trial: 4. Best value: 0.0297594:   5%|         | 5/100 [00:00<00:00, 791.62it/s]Best trial: 4. Best value: 0.0297594:   5%|         | 5/100 [00:00<00:00, 780.13it/s]                                                                                      Best trial: 4. Best value: 0.0297594:   6%|         | 6/100 [00:00<00:00, 839.73it/s]Best trial: 4. Best value: 0.0297594:   6%|         | 6/100 [00:00<00:00, 829.05it/s]                                                                                      Best trial: 4. Best value: 0.0297594:   7%|         | 7/100 [00:00<00:00, 883.46it/s]Best trial: 4. Best value: 0.0297594:   7%|         | 7/100 [00:00<00:00, 873.79it/s]                                                                                      Best trial: 4. Best value: 0.0297594:   8%|         | 8/100 [00:00<00:00, 917.01it/s]Best trial: 4. Best value: 0.0297594:   8%|         | 8/100 [00:00<00:00, 907.20it/s]                                                                                      Best trial: 4. Best value: 0.0297594:   9%|         | 9/100 [00:00<00:00, 945.56it/s]Best trial: 4. Best value: 0.0297594:   9%|         | 9/100 [00:00<00:00, 935.72it/s]                                                                                      Best trial: 4. Best value: 0.0297594:  10%|         | 10/100 [00:00<00:00, 817.05it/s]Best trial: 10. Best value: 0.0300784:  10%|         | 10/100 [00:00<00:00, 809.18it/s]                                                                                        Best trial: 10. Best value: 0.0300784:  11%|         | 11/100 [00:00<00:00, 736.08it/s]Best trial: 11. Best value: 0.0301347:  11%|         | 11/100 [00:00<00:00, 728.42it/s]                                                                                        Best trial: 11. Best value: 0.0301347:  12%|        | 12/100 [00:00<00:00, 683.91it/s]Best trial: 12. Best value: 0.030138:  12%|        | 12/100 [00:00<00:00, 679.15it/s]                                                                                        Best trial: 12. Best value: 0.030138:  13%|        | 13/100 [00:00<00:00, 660.76it/s]Best trial: 12. Best value: 0.030138:  13%|        | 13/100 [00:00<00:00, 657.03it/s]                                                                                       Best trial: 12. Best value: 0.030138:  14%|        | 14/100 [00:00<00:00, 643.85it/s]Best trial: 14. Best value: 0.0304321:  14%|        | 14/100 [00:00<00:00, 640.73it/s]                                                                                        Best trial: 14. Best value: 0.0304321:  15%|        | 15/100 [00:00<00:00, 631.10it/s]Best trial: 14. Best value: 0.0304321:  15%|        | 15/100 [00:00<00:00, 628.47it/s]                                                                                        Best trial: 14. Best value: 0.0304321:  16%|        | 16/100 [00:00<00:00, 621.71it/s]Best trial: 14. Best value: 0.0304321:  16%|        | 16/100 [00:00<00:00, 619.26it/s]                                                                                        Best trial: 14. Best value: 0.0304321:  17%|        | 17/100 [00:00<00:00, 613.29it/s]Best trial: 14. Best value: 0.0304321:  17%|        | 17/100 [00:00<00:00, 611.07it/s]                                                                                        Best trial: 14. Best value: 0.0304321:  18%|        | 18/100 [00:00<00:00, 605.75it/s]Best trial: 18. Best value: 0.0306712:  18%|        | 18/100 [00:00<00:00, 603.72it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  19%|        | 19/100 [00:00<00:00, 598.78it/s]Best trial: 18. Best value: 0.0306712:  19%|        | 19/100 [00:00<00:00, 596.88it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  20%|        | 20/100 [00:00<00:00, 591.03it/s]Best trial: 18. Best value: 0.0306712:  20%|        | 20/100 [00:00<00:00, 588.98it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  21%|        | 21/100 [00:00<00:00, 581.89it/s]Best trial: 18. Best value: 0.0306712:  21%|        | 21/100 [00:00<00:00, 580.03it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  22%|       | 22/100 [00:00<00:00, 576.03it/s]Best trial: 18. Best value: 0.0306712:  22%|       | 22/100 [00:00<00:00, 574.41it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  23%|       | 23/100 [00:00<00:00, 571.21it/s]Best trial: 18. Best value: 0.0306712:  23%|       | 23/100 [00:00<00:00, 569.77it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  24%|       | 24/100 [00:00<00:00, 567.63it/s]Best trial: 18. Best value: 0.0306712:  24%|       | 24/100 [00:00<00:00, 566.29it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  25%|       | 25/100 [00:00<00:00, 565.46it/s]Best trial: 18. Best value: 0.0306712:  25%|       | 25/100 [00:00<00:00, 564.13it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  26%|       | 26/100 [00:00<00:00, 563.44it/s]Best trial: 18. Best value: 0.0306712:  26%|       | 26/100 [00:00<00:00, 562.27it/s]                                                                                        Best trial: 18. Best value: 0.0306712:  27%|       | 27/100 [00:00<00:00, 561.73it/s]Best trial: 27. Best value: 0.030679:  27%|       | 27/100 [00:00<00:00, 560.61it/s]                                                                                        Best trial: 27. Best value: 0.030679:  28%|       | 28/100 [00:00<00:00, 523.68it/s]Best trial: 28. Best value: 0.0306791:  28%|       | 28/100 [00:00<00:00, 522.68it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  29%|       | 29/100 [00:00<00:00, 522.78it/s]Best trial: 28. Best value: 0.0306791:  29%|       | 29/100 [00:00<00:00, 521.87it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  30%|       | 30/100 [00:00<00:00, 522.32it/s]Best trial: 28. Best value: 0.0306791:  30%|       | 30/100 [00:00<00:00, 521.44it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  31%|       | 31/100 [00:00<00:00, 521.45it/s]Best trial: 28. Best value: 0.0306791:  31%|       | 31/100 [00:00<00:00, 520.60it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  32%|      | 32/100 [00:00<00:00, 520.82it/s]Best trial: 28. Best value: 0.0306791:  32%|      | 32/100 [00:00<00:00, 520.03it/s]                                                                                        [I 2025-11-13 15:29:18,148] Trial 0 finished with value: 0.027840225171010927 and parameters: {'weight_0': 0.3745401188473625, 'weight_1': 0.9507143064099162, 'weight_2': 0.7319939418114051}. Best is trial 0 with value: 0.027840225171010927.
[I 2025-11-13 15:29:18,149] Trial 1 finished with value: 0.029713790653576523 and parameters: {'weight_0': 0.5986584841970366, 'weight_1': 0.15601864044243652, 'weight_2': 0.15599452033620265}. Best is trial 1 with value: 0.029713790653576523.
[I 2025-11-13 15:29:18,150] Trial 2 finished with value: 0.027959541143417022 and parameters: {'weight_0': 0.05808361216819946, 'weight_1': 0.8661761457749352, 'weight_2': 0.6011150117432088}. Best is trial 1 with value: 0.029713790653576523.
[I 2025-11-13 15:29:18,151] Trial 3 finished with value: 0.028139200466319896 and parameters: {'weight_0': 0.7080725777960455, 'weight_1': 0.020584494295802447, 'weight_2': 0.9699098521619943}. Best is trial 1 with value: 0.029713790653576523.
[I 2025-11-13 15:29:18,151] Trial 4 finished with value: 0.029759370440850818 and parameters: {'weight_0': 0.8324426408004217, 'weight_1': 0.21233911067827616, 'weight_2': 0.18182496720710062}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,152] Trial 5 finished with value: 0.022057782777529053 and parameters: {'weight_0': 0.18340450985343382, 'weight_1': 0.3042422429595377, 'weight_2': 0.5247564316322378}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,153] Trial 6 finished with value: 0.029708648572818415 and parameters: {'weight_0': 0.43194501864211576, 'weight_1': 0.2912291401980419, 'weight_2': 0.6118528947223795}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,154] Trial 7 finished with value: 0.025388345622206276 and parameters: {'weight_0': 0.13949386065204183, 'weight_1': 0.29214464853521815, 'weight_2': 0.3663618432936917}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,155] Trial 8 finished with value: 0.02741501370109748 and parameters: {'weight_0': 0.45606998421703593, 'weight_1': 0.7851759613930136, 'weight_2': 0.19967378215835974}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,155] Trial 9 finished with value: 0.026339087289464616 and parameters: {'weight_0': 0.5142344384136116, 'weight_1': 0.5924145688620425, 'weight_2': 0.046450412719997725}. Best is trial 4 with value: 0.029759370440850818.
[I 2025-11-13 15:29:18,158] Trial 10 finished with value: 0.03007840688591567 and parameters: {'weight_0': 0.9779960740812002, 'weight_1': 0.5588508982574674, 'weight_2': 0.3105851790593912}. Best is trial 10 with value: 0.03007840688591567.
[I 2025-11-13 15:29:18,161] Trial 11 finished with value: 0.030134742280229825 and parameters: {'weight_0': 0.9526412567603433, 'weight_1': 0.5522332938560958, 'weight_2': 0.3360567190779755}. Best is trial 11 with value: 0.030134742280229825.
[I 2025-11-13 15:29:18,163] Trial 12 finished with value: 0.030137995850331403 and parameters: {'weight_0': 0.9848399166996231, 'weight_1': 0.5777983410965586, 'weight_2': 0.33479517622323646}. Best is trial 12 with value: 0.030137995850331403.
[I 2025-11-13 15:29:18,166] Trial 13 finished with value: 0.028500273493795168 and parameters: {'weight_0': 0.9976856252039022, 'weight_1': 0.6787145381076652, 'weight_2': 0.39281412499771245}. Best is trial 12 with value: 0.030137995850331403.
[I 2025-11-13 15:29:18,168] Trial 14 finished with value: 0.03043206239263714 and parameters: {'weight_0': 0.8269980395822951, 'weight_1': 0.43435627175641134, 'weight_2': 0.4186541565354}. Best is trial 14 with value: 0.03043206239263714.
[I 2025-11-13 15:29:18,170] Trial 15 finished with value: 0.02953877848989116 and parameters: {'weight_0': 0.7860747708629257, 'weight_1': 0.42711230563333175, 'weight_2': 0.7676259977007913}. Best is trial 14 with value: 0.03043206239263714.
[I 2025-11-13 15:29:18,172] Trial 16 finished with value: 0.030053354859344652 and parameters: {'weight_0': 0.8577739195460599, 'weight_1': 0.4239204270288165, 'weight_2': 0.4759567767666123}. Best is trial 14 with value: 0.03043206239263714.
[I 2025-11-13 15:29:18,174] Trial 17 finished with value: 0.025488091843244947 and parameters: {'weight_0': 0.6895366011206422, 'weight_1': 0.7203614990571352, 'weight_2': 0.46909462904866916}. Best is trial 14 with value: 0.03043206239263714.
[I 2025-11-13 15:29:18,176] Trial 18 finished with value: 0.03067124633980734 and parameters: {'weight_0': 0.8717363094427023, 'weight_1': 0.42403478334326783, 'weight_2': 0.02182030219559805}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,178] Trial 19 finished with value: 0.02930115515274797 and parameters: {'weight_0': 0.6223015030821928, 'weight_1': 0.43896220797889185, 'weight_2': 0.006651865910525578}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,180] Trial 20 finished with value: 0.028490444666050316 and parameters: {'weight_0': 0.8682382020267405, 'weight_1': 0.03979083985704124, 'weight_2': 0.11289497920055908}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,182] Trial 21 finished with value: 0.030377661705372712 and parameters: {'weight_0': 0.9082694349794638, 'weight_1': 0.48769852588633017, 'weight_2': 0.223973725904685}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,184] Trial 22 finished with value: 0.03001272830916278 and parameters: {'weight_0': 0.7539264586930019, 'weight_1': 0.37863691986475795, 'weight_2': 0.24059702581126582}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,186] Trial 23 finished with value: 0.030072413918045098 and parameters: {'weight_0': 0.8887312561704293, 'weight_1': 0.47316462772122425, 'weight_2': 0.09049120691719717}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,188] Trial 24 finished with value: 0.02688462858930272 and parameters: {'weight_0': 0.6240899008693761, 'weight_1': 0.6491566404170359, 'weight_2': 0.2419302604318191}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,190] Trial 25 finished with value: 0.028534820869744962 and parameters: {'weight_0': 0.9136171774585753, 'weight_1': 0.4988625656421456, 'weight_2': 0.0021198360516174325}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,192] Trial 26 finished with value: 0.030239988558954496 and parameters: {'weight_0': 0.787777751073494, 'weight_1': 0.351521658133212, 'weight_2': 0.2669037520755527}. Best is trial 18 with value: 0.03067124633980734.
[I 2025-11-13 15:29:18,194] Trial 27 finished with value: 0.03067902951644591 and parameters: {'weight_0': 0.7061759023477681, 'weight_1': 0.14158424165235128, 'weight_2': 0.08975578654168942}. Best is trial 27 with value: 0.03067902951644591.
[I 2025-11-13 15:29:18,199] Trial 28 finished with value: 0.030679054677985394 and parameters: {'weight_0': 0.7059388023638251, 'weight_1': 0.14218059134759864, 'weight_2': 0.10353760571433257}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,201] Trial 29 finished with value: 0.029997823312281232 and parameters: {'weight_0': 0.5339025034837662, 'weight_1': 0.11755251146281763, 'weight_2': 0.1105133651533148}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,203] Trial 30 finished with value: 0.02835434233642828 and parameters: {'weight_0': 0.31068941969799646, 'weight_1': 0.20317492802821863, 'weight_2': 0.07865071028124304}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,205] Trial 31 finished with value: 0.02819700082927579 and parameters: {'weight_0': 0.6780648619361206, 'weight_1': 0.0984459999893666, 'weight_2': 0.782451084241675}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,207] Trial 32 finished with value: 0.029557420930908705 and parameters: {'weight_0': 0.7427154380727187, 'weight_1': 0.2114371815741001, 'weight_2': 0.13770282663566552}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,209] Trial 33 finished with value: 0.028315886067814284 and parameters: {'weight_0': 0.5672904819084943, 'weight_1': 0.988171812603357, 'weight_2': 0.04899460788268418}. Best is trial 28 with value: 0.030679054677985394.Best trial: 28. Best value: 0.0306791:  33%|      | 33/100 [00:00<00:00, 519.86it/s]Best trial: 28. Best value: 0.0306791:  33%|      | 33/100 [00:00<00:00, 519.05it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  34%|      | 34/100 [00:00<00:00, 519.17it/s]Best trial: 28. Best value: 0.0306791:  34%|      | 34/100 [00:00<00:00, 518.39it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  35%|      | 35/100 [00:00<00:00, 516.79it/s]Best trial: 28. Best value: 0.0306791:  35%|      | 35/100 [00:00<00:00, 515.96it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  36%|      | 36/100 [00:00<00:00, 513.22it/s]Best trial: 28. Best value: 0.0306791:  36%|      | 36/100 [00:00<00:00, 512.35it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  37%|      | 37/100 [00:00<00:00, 511.72it/s]Best trial: 28. Best value: 0.0306791:  37%|      | 37/100 [00:00<00:00, 511.01it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  38%|      | 38/100 [00:00<00:00, 510.55it/s]Best trial: 28. Best value: 0.0306791:  38%|      | 38/100 [00:00<00:00, 509.86it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  39%|      | 39/100 [00:00<00:00, 510.42it/s]Best trial: 28. Best value: 0.0306791:  39%|      | 39/100 [00:00<00:00, 509.78it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  40%|      | 40/100 [00:00<00:00, 509.59it/s]Best trial: 28. Best value: 0.0306791:  40%|      | 40/100 [00:00<00:00, 508.96it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  41%|      | 41/100 [00:00<00:00, 509.20it/s]Best trial: 28. Best value: 0.0306791:  41%|      | 41/100 [00:00<00:00, 508.59it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  42%|     | 42/100 [00:00<00:00, 508.56it/s]Best trial: 28. Best value: 0.0306791:  42%|     | 42/100 [00:00<00:00, 507.94it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  43%|     | 43/100 [00:00<00:00, 507.52it/s]Best trial: 28. Best value: 0.0306791:  43%|     | 43/100 [00:00<00:00, 506.86it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  44%|     | 44/100 [00:00<00:00, 506.67it/s]Best trial: 28. Best value: 0.0306791:  44%|     | 44/100 [00:00<00:00, 506.07it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  45%|     | 45/100 [00:00<00:00, 505.26it/s]Best trial: 28. Best value: 0.0306791:  45%|     | 45/100 [00:00<00:00, 504.64it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  46%|     | 46/100 [00:00<00:00, 504.08it/s]Best trial: 28. Best value: 0.0306791:  46%|     | 46/100 [00:00<00:00, 503.53it/s]                                                                                        Best trial: 28. Best value: 0.0306791:  47%|     | 47/100 [00:00<00:00, 503.56it/s]Best trial: 47. Best value: 0.0307768:  47%|     | 47/100 [00:00<00:00, 503.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  48%|     | 48/100 [00:00<00:00, 503.19it/s]Best trial: 47. Best value: 0.0307768:  48%|     | 48/100 [00:00<00:00, 502.67it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  49%|     | 49/100 [00:00<00:00, 502.68it/s]Best trial: 47. Best value: 0.0307768:  49%|     | 49/100 [00:00<00:00, 502.17it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  50%|     | 50/100 [00:00<00:00, 502.25it/s]Best trial: 47. Best value: 0.0307768:  50%|     | 50/100 [00:00<00:00, 501.74it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  51%|     | 51/100 [00:00<00:00, 501.79it/s]Best trial: 47. Best value: 0.0307768:  51%|     | 51/100 [00:00<00:00, 501.32it/s]Best trial: 47. Best value: 0.0307768:  52%|    | 52/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  52%|    | 52/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  52%|    | 52/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  53%|    | 53/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  53%|    | 53/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  54%|    | 54/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  54%|    | 54/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  55%|    | 55/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  55%|    | 55/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  56%|    | 56/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  56%|    | 56/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  57%|    | 57/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  57%|    | 57/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  58%|    | 58/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  58%|    | 58/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  59%|    | 59/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  59%|    | 59/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  60%|    | 60/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  60%|    | 60/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  61%|    | 61/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  61%|    | 61/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  62%|   | 62/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  62%|   | 62/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  63%|   | 63/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  63%|   | 63/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  64%|   | 64/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  64%|   | 64/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  65%|   | 65/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  65%|   | 65/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  66%|   | 66/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  66%|   | 66/100 [00:00<00:00, 511.02it/s]                                                                                        
[I 2025-11-13 15:29:18,211] Trial 34 finished with value: 0.029393192459698313 and parameters: {'weight_0': 0.8287244225491834, 'weight_1': 0.07213029363365857, 'weight_2': 0.1701199433872185}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,214] Trial 35 finished with value: 0.02974806785855584 and parameters: {'weight_0': 0.6708474095594911, 'weight_1': 0.18129075139167156, 'weight_2': 0.9309781571936999}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,216] Trial 36 finished with value: 0.029547498682929784 and parameters: {'weight_0': 0.8126817100330669, 'weight_1': 0.2521169660756474, 'weight_2': 0.6432424054379785}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,218] Trial 37 finished with value: 0.028088997537683902 and parameters: {'weight_0': 0.7477529380833817, 'weight_1': 0.006239818063549923, 'weight_2': 0.5431578696257401}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,220] Trial 38 finished with value: 0.029555500528577708 and parameters: {'weight_0': 0.301030493325267, 'weight_1': 0.15045934841909817, 'weight_2': 0.40355193042836873}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,222] Trial 39 finished with value: 0.02942013175374518 and parameters: {'weight_0': 0.584888277409664, 'weight_1': 0.3443358722373057, 'weight_2': 0.17276010984517864}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,224] Trial 40 finished with value: 0.02632582592064519 and parameters: {'weight_0': 0.7200134485563335, 'weight_1': 0.8403182490484036, 'weight_2': 0.052042832698537836}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,226] Trial 41 finished with value: 0.029762633890650585 and parameters: {'weight_0': 0.9372447815782872, 'weight_1': 0.244151244663605, 'weight_2': 0.2120012310524231}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,229] Trial 42 finished with value: 0.030239448019258167 and parameters: {'weight_0': 0.9127620265024355, 'weight_1': 0.3868984591480138, 'weight_2': 0.13758374021720726}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,231] Trial 43 finished with value: 0.02988495411030942 and parameters: {'weight_0': 0.8369089476019788, 'weight_1': 0.29279836555485483, 'weight_2': 0.28683183764835385}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,233] Trial 44 finished with value: 0.02895830666748799 and parameters: {'weight_0': 0.6490680029882974, 'weight_1': 0.4841812324180571, 'weight_2': 0.20676193111734525}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,235] Trial 45 finished with value: 0.0285391199290739 and parameters: {'weight_0': 0.7919808714609725, 'weight_1': 0.5343552700864683, 'weight_2': 0.006641420625879149}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,237] Trial 46 finished with value: 0.028292242825734573 and parameters: {'weight_0': 0.8814152730467114, 'weight_1': 0.6006933374877537, 'weight_2': 0.43549165668397527}. Best is trial 28 with value: 0.030679054677985394.
[I 2025-11-13 15:29:18,239] Trial 47 finished with value: 0.030776782949899863 and parameters: {'weight_0': 0.7160435039281987, 'weight_1': 0.1362064202943688, 'weight_2': 0.0665343019001332}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,241] Trial 48 finished with value: 0.02954412469043926 and parameters: {'weight_0': 0.4654244994256224, 'weight_1': 0.1346296532924936, 'weight_2': 0.07064311434205783}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,243] Trial 49 finished with value: 0.028121772732875222 and parameters: {'weight_0': 0.5504219095744282, 'weight_1': 0.07689265150147159, 'weight_2': 0.673988046230876}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,245] Trial 50 finished with value: 0.029888696288429845 and parameters: {'weight_0': 0.6970354295588416, 'weight_1': 0.24698228934185787, 'weight_2': 0.1371756812711814}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,248] Trial 51 finished with value: 0.030390844344007642 and parameters: {'weight_0': 0.7711258942083336, 'weight_1': 0.33226011494784824, 'weight_2': 0.040273510495324905}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,250] Trial 52 finished with value: 0.027510019159369244 and parameters: {'weight_0': 0.03788908584154238, 'weight_1': 0.16452659407758166, 'weight_2': 0.03539983756396951}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,252] Trial 53 finished with value: 0.030373570277851026 and parameters: {'weight_0': 0.7741475428763561, 'weight_1': 0.3325586664383529, 'weight_2': 0.09751439457969205}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,254] Trial 54 finished with value: 0.030159220065891935 and parameters: {'weight_0': 0.7181497705992291, 'weight_1': 0.2733020550863032, 'weight_2': 0.03329896634330685}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,256] Trial 55 finished with value: 0.028188433876480484 and parameters: {'weight_0': 0.6141158307332673, 'weight_1': 0.39498164597698915, 'weight_2': 0.14804937760058406}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,258] Trial 56 finished with value: 0.02861872649531392 and parameters: {'weight_0': 0.8483092678188154, 'weight_1': 0.04273917822591414, 'weight_2': 0.08261891280746494}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,260] Trial 57 finished with value: 0.028767395660828837 and parameters: {'weight_0': 0.6455878389309205, 'weight_1': 0.45088522178407364, 'weight_2': 0.8440455048363276}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,262] Trial 58 finished with value: 0.029595308256384685 and parameters: {'weight_0': 0.9507250397498381, 'weight_1': 0.31973811989591294, 'weight_2': 0.5261638523744266}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,264] Trial 59 finished with value: 0.02856749356580125 and parameters: {'weight_0': 0.8020930419287219, 'weight_1': 0.5267245121032347, 'weight_2': 0.11469739677988339}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,266] Trial 60 finished with value: 0.02900311779740171 and parameters: {'weight_0': 0.12652268937123562, 'weight_1': 0.10045413985921203, 'weight_2': 0.570599706503004}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,268] Trial 61 finished with value: 0.030198515408476755 and parameters: {'weight_0': 0.8761088809949117, 'weight_1': 0.40041109107984746, 'weight_2': 0.3367464959338373}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,271] Trial 62 finished with value: 0.028432837581296708 and parameters: {'weight_0': 0.7625692421581849, 'weight_1': 0.45808311508977406, 'weight_2': 0.03964038601976885}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,273] Trial 63 finished with value: 0.030273056537321503 and parameters: {'weight_0': 0.9225428191712712, 'weight_1': 0.4288084220895492, 'weight_2': 0.19403883298616936}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,275] Trial 64 finished with value: 0.03010966791507299 and parameters: {'weight_0': 0.9852077475702732, 'weight_1': 0.3610264328487771, 'weight_2': 0.00038502324170427635}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,277] Trial 65 finished with value: 0.028439325211838257 and parameters: {'weight_0': 0.8231576394659591, 'weight_1': 0.5069565360073686, 'weight_2': 0.07642650856845971}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,279] Trial 66 finished with value: 0.029017146745313676 and parameters: {'weight_0': 0.7295945957970803, 'weight_1': 0.5996659703117286, 'weight_2': 0.27199551740153183}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,281] Trial 67 finished with value: 0.03007025161326404 and parameters: {'weight_0': 0.8959594776812293, 'weight_1': 0.2013726901855628, 'weight_2': 0.2384418253220597}. Best is trial 47 with value: 0.030776782949899863.Best trial: 47. Best value: 0.0307768:  67%|   | 67/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  67%|   | 67/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  68%|   | 68/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  68%|   | 68/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  69%|   | 69/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  69%|   | 69/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  70%|   | 70/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  70%|   | 70/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  71%|   | 71/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  71%|   | 71/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  72%|  | 72/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  72%|  | 72/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  73%|  | 73/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  73%|  | 73/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  74%|  | 74/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  74%|  | 74/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  75%|  | 75/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  75%|  | 75/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  76%|  | 76/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  76%|  | 76/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  77%|  | 77/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  77%|  | 77/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  78%|  | 78/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  78%|  | 78/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  79%|  | 79/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  79%|  | 79/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  80%|  | 80/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  80%|  | 80/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  81%|  | 81/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  81%|  | 81/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  82%| | 82/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  82%| | 82/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  83%| | 83/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  83%| | 83/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  84%| | 84/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  84%| | 84/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  85%| | 85/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  85%| | 85/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  86%| | 86/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  86%| | 86/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  87%| | 87/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  87%| | 87/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  88%| | 88/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  88%| | 88/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  89%| | 89/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  89%| | 89/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  90%| | 90/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  90%| | 90/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  91%| | 91/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  91%| | 91/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  92%|| 92/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  92%|| 92/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  93%|| 93/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  93%|| 93/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  94%|| 94/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  94%|| 94/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  95%|| 95/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  95%|| 95/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  96%|| 96/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  96%|| 96/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  97%|| 97/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  97%|| 97/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  98%|| 98/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  98%|| 98/100 [00:00<00:00, 511.02it/s]                                                                                        Best trial: 47. Best value: 0.0307768:  99%|| 99/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768:  99%|| 99/100 [00:00<00:00, 511.02it/s]Best trial: 47. Best value: 0.0307768: 100%|| 100/100 [00:00<00:00, 487.73it/s]

[I 2025-11-13 15:29:18,283] Trial 68 finished with value: 0.028396079711366488 and parameters: {'weight_0': 0.8522752694518746, 'weight_1': 0.051975510061038455, 'weight_2': 0.11254675256410636}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,285] Trial 69 finished with value: 0.027566300708223038 and parameters: {'weight_0': 0.6647529950681155, 'weight_1': 0.5648382063156615, 'weight_2': 0.16554477764848952}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,288] Trial 70 finished with value: 0.030623383207910405 and parameters: {'weight_0': 0.7006880470476995, 'weight_1': 0.14018386196037996, 'weight_2': 0.06155653633174282}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,290] Trial 71 finished with value: 0.02977327226409889 and parameters: {'weight_0': 0.751436441892172, 'weight_1': 0.17212340960783679, 'weight_2': 0.05894368775000766}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,292] Trial 72 finished with value: 0.03000817242882913 and parameters: {'weight_0': 0.6935574605656228, 'weight_1': 0.11026936753323316, 'weight_2': 0.034160352961161766}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,294] Trial 73 finished with value: 0.030198907707891746 and parameters: {'weight_0': 0.7901366950307633, 'weight_1': 0.13041206791267304, 'weight_2': 0.11915806906604823}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,296] Trial 74 finished with value: 0.02993538944236876 and parameters: {'weight_0': 0.5932964162657013, 'weight_1': 0.22284562513045245, 'weight_2': 0.08688693094076055}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,298] Trial 75 finished with value: 0.02806978354557659 and parameters: {'weight_0': 0.8177109578821743, 'weight_1': 0.0004408026398192155, 'weight_2': 0.020850415736593554}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,300] Trial 76 finished with value: 0.02969490401622454 and parameters: {'weight_0': 0.9590672464662663, 'weight_1': 0.08302743491886636, 'weight_2': 0.06327214971790474}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,302] Trial 77 finished with value: 0.03046290400678112 and parameters: {'weight_0': 0.5079780680239648, 'weight_1': 0.27880383288679456, 'weight_2': 0.21910433764720133}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,305] Trial 78 finished with value: 0.030428218335447833 and parameters: {'weight_0': 0.5048251668966697, 'weight_1': 0.27732772783333837, 'weight_2': 0.18314553209365314}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,307] Trial 79 finished with value: 0.028872125500442297 and parameters: {'weight_0': 0.41417884708700753, 'weight_1': 0.2691546259039016, 'weight_2': 0.310472906966504}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,309] Trial 80 finished with value: 0.029513278000063092 and parameters: {'weight_0': 0.49331470856288423, 'weight_1': 0.14985958728982873, 'weight_2': 0.18280733318037484}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,311] Trial 81 finished with value: 0.028970006776164414 and parameters: {'weight_0': 0.38083087881262323, 'weight_1': 0.3192956767257993, 'weight_2': 0.1481002965652949}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,313] Trial 82 finished with value: 0.02996017793491722 and parameters: {'weight_0': 0.5025338206730804, 'weight_1': 0.1911799707750868, 'weight_2': 0.10160001868330512}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,316] Trial 83 finished with value: 0.026778338039356496 and parameters: {'weight_0': 0.3178819745088537, 'weight_1': 0.3035044845770753, 'weight_2': 0.1291378492479921}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,318] Trial 84 finished with value: 0.030025417077161966 and parameters: {'weight_0': 0.5708555337849678, 'weight_1': 0.23265021630938104, 'weight_2': 0.06272023159588405}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,320] Trial 85 finished with value: 0.03002107642005923 and parameters: {'weight_0': 0.638648709011742, 'weight_1': 0.2777604926213531, 'weight_2': 0.38978421431468424}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,322] Trial 86 finished with value: 0.02891536377201822 and parameters: {'weight_0': 0.5264918654682129, 'weight_1': 0.40910742337522377, 'weight_2': 0.018415591905435194}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,324] Trial 87 finished with value: 0.030201845972895006 and parameters: {'weight_0': 0.7124349495390639, 'weight_1': 0.3480524197555629, 'weight_2': 0.21749144776134047}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,327] Trial 88 finished with value: 0.028912976315783226 and parameters: {'weight_0': 0.45783668078590134, 'weight_1': 0.3794977777637165, 'weight_2': 0.47116646540648327}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,329] Trial 89 finished with value: 0.02947256770977341 and parameters: {'weight_0': 0.6099059648092181, 'weight_1': 0.1858237760968352, 'weight_2': 0.15803022812197698}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,331] Trial 90 finished with value: 0.029069025697920158 and parameters: {'weight_0': 0.2631813239799393, 'weight_1': 0.2185177695216846, 'weight_2': 0.092542314456929}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,333] Trial 91 finished with value: 0.02801529909255659 and parameters: {'weight_0': 0.7698760386438378, 'weight_1': 0.4821611914927821, 'weight_2': 0.24458931247264418}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,335] Trial 92 finished with value: 0.03036326821501071 and parameters: {'weight_0': 0.736813311593664, 'weight_1': 0.1396809910966682, 'weight_2': 0.303500322507817}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,338] Trial 93 finished with value: 0.030341000228185824 and parameters: {'weight_0': 0.910473879973928, 'weight_1': 0.4197868534502812, 'weight_2': 0.22953512774289517}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,340] Trial 94 finished with value: 0.03019144613651487 and parameters: {'weight_0': 0.6686983486478028, 'weight_1': 0.2611911161616517, 'weight_2': 0.04932068902272771}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,342] Trial 95 finished with value: 0.027916515276312316 and parameters: {'weight_0': 0.8479105320925726, 'weight_1': 0.5040058404529482, 'weight_2': 0.18582945524837868}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,344] Trial 96 finished with value: 0.03040139962234633 and parameters: {'weight_0': 0.697290582631535, 'weight_1': 0.3679102571307342, 'weight_2': 0.35928340746208015}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,346] Trial 97 finished with value: 0.030267147625010954 and parameters: {'weight_0': 0.717466067418761, 'weight_1': 0.31564236215194424, 'weight_2': 0.35806165396454764}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,349] Trial 98 finished with value: 0.030136398957327143 and parameters: {'weight_0': 0.7034608851229571, 'weight_1': 0.3593948387683114, 'weight_2': 0.49075791549351394}. Best is trial 47 with value: 0.030776782949899863.
[I 2025-11-13 15:29:18,351] Trial 99 finished with value: 0.028568394865067688 and parameters: {'weight_0': 0.6844649990010391, 'weight_1': 0.44739054256894856, 'weight_2': 0.028288684320408708}. Best is trial 47 with value: 0.030776782949899863.
